- Assume most recent language standard are available (ES6)
- We expect good performance.
- If missing more requirements details, just make reasonable assumptions of
your own.
- Solution must be simple and compact.
  No defensive coding, no comments, no unrequested features.
  Only one file 10-20 lines of code
- Work only inside Google Docs: no external editor/IDE/debugger, no copy-paste
  to/from such an editor. We must see the flow of how you write the code.

Note: you have a total of 60 minutes for both questions
(1)
Implement function verify(text) which verifies whether parentheses within text are
correctly nested. You need to consider three kinds: (), [], <> and only these kinds.
 Examples  
verify("---(++++)----") -> 1
verify("") -> 1
verify("before ( middle []) after ") -> 1 
verify(") (") -> 0
verify("<(   >)") -> 0
verify("(  [  <>  ()  ]  <>  )") -> 1
verify("   (      [)") -> 
  // wow , wow
 verify = (str) => {
If (str.match(/[\(\)\[\]\<\>]/g) == null) { return 1; } 
 	let s = str.match(/[\(\)\[\]\<\>]/g).toString(“”).replace(/,/g “”);
	let sLength = s.length;
	if (sLength % 2 !==0) { return 0;}
	let i = 0;
	while (i < sLength - 2) {
if (
(s.charAt(i) == “(“  &&  s.charAt(i+1) == “)”)  ||
(s.charAt(i) ==”[“ && s.charAt(i+1) == “]”)  ||
(s.charAt(i) == “<” && s.charAt(i+1) ==”>”)
) {
s = s.substring(0,i) + s.substring(i+2);
i = i - 2; }
i++;
} 
if (s.length == 0) { return 1; }
else { return 0;}
       };
(2)
Problem
Simplify the implementation below as much as you can.
Even better if you can also improve performance as part of the simplification!
FYI: This code is over 35 lines and over 300 tokens, but it can be written in
5 lines and in less than 60 tokens.
Function on the next page.

function func(s, a, b)
{
    var match_empty=/^$/ ;
    if (s.match(match_empty))
    {
        return -1;
    }
    else
    {
        var i=s.length-1;
        var aIndex=-1;
        var bIndex=-1;
        while ((aIndex==-1) && (bIndex==-1) && (i>=0))
        {
            if (s.substring(i, i+1) == a)
                aIndex=i;
        	if (s.substring(i, i+1) == b)
                bIndex=i;
        	i--;
        }
        if (aIndex != -1)
        {
            if (bIndex == -1)
                return aIndex;
        	else
                return Math.max(aIndex, bIndex);
        }
        else
        {
            if (bIndex != -1)
                return bIndex;       
	      else
                return -1;
        }
    }
};
     func = (s, a, b) => {
        if ( s.length == 0 || ( s.indexOf(a) == -1 && s.indexOf(b) == -1) {
return -1;
} else {
return Math.max(s.lastIndexOf(a), s.lastIndexOf(b));  
}; 




